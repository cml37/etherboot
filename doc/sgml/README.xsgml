<!doctype linuxdoc system>

<article>

<title>Etherboot README
<author>Markus Gutschke and Ken Yap,
<tt/markus+etherboot@gutschke.com/, <tt/ken_yap@users.sourceforge.net/
<date>13 Oct 2000

<abstract>
This is the README file for the Etherboot package. This document
explains how to install, configure and use the Etherboot package.
The instructions here apply to version 4.6 of Etherboot.
</abstract>

<toc>

<sect>Introduction

<p>

Etherboot is a package for creating ROM images that can download code
over the network to be executed on an x86 computer. Etherboot requires
the PC architecture, it does not work for other Linux platforms such as
Alphas or Suns. Typically the computer is diskless and the code is Linux
or FreeBSD, but these are not the only possibilities. The code uses the
bootp, tftp and NFS Internet Protocols.

<p>

Etherboot is Open Source. Please support it by joining the Open Source
community and sharing. See the Etherboot home page for some ways you
can help Etherboot.

<p>

<it>Disclaimer: Etherboot comes with NO warranties of any kind. It is
hoped that it will be useful to you, and NO responsibility is accepted for
any outcome of using it. Etherboot also comes with NO support, although
you can get helpful advice from the Netboot mailing list referred to on
the Etherboot home page, and from the Internet in general.</it>

<sect1>What hardware is supported?

<p>

The following is the current NIC configuration file as of m4_esyscmd(date '+%Y-%m-%d.')
Even if your NIC does not appear in the list, it may still be supported
if the chip is one of those supported.  Many OEMs use chips from
foundries. An exhaustive list of brand names is impossible.  The best
strategy is to read the number on the LAN controller chip on the board.

<code>
m4_include(`../src/NIC')
</code>

<p>

All Etherboot drivers are autoprobing, which means they attempt to detect
the hardware addresses at which the card is installed. It's fairly easy
to write a driver if you know C and are familiar with Ethernet hardware
interfacing. Please read the section on <ref name="Writing an Etherboot
Driver" id="driver"> if you wish to do so.

<sect1>Availability of this document

<p>

This document and related documents are also kept online at <url
url="http://etherboot.sourceforge.net/" name="the Etherboot Home Page">.
This will in general have the latest distributions and documentation.

<p>

The contents of this document are copyright Ken Yap and Markus Gutschke.
However permission is granted to copy and reproduce this document in
full or in part provided this document is identified as the source.

<p>

For a talk/tutorial type introduction to what Etherboot does and how to
set it up, see my <url url="diskless.html" name="SLUG talk">. You may
wish to review this before reading further.

<p>

An older version of this README, which is now out of date, can be
accessed via <url url="old-README.html" name="this link">.

<sect1>Getting help

<p>

There is a mailing list for all netbooting related
issues. To subscribe follow the instructions on the <url
url="http://etherboot.sourceforge.net/" name="Etherboot home page">.

<p>

With the major exception of the following section, and the section on
Writing an Etherboot Driver, most of the information on diskless booting
is not specific to Etherboot but can be used for the Netboot package also.

<sect>Unpacking, compiling and testing the package

<p>

<em>This section is Etherboot specific.</em>

<sect1>Unpacking the distribution

<p>

Unpack the distribution using gunzip and tar, using one of the following
commands, where you replace x by the patchlevel number:

<p>

<code>
	tar zxvf etherboot-4.6.x.tar.gz
	gunzip < etherboot-4.6.x.tar.gz | tar xvf -
	bunzip2 < etherboot-4.6.x.tar.bz2 | tar xvf -
</code>

<sect1>Compiling the ROM images

<p>

To build the ROM images you need a recent release of gcc and the
binutils tools. This package was compiled with the tools from a RedHat
6.0 distribution but it should work with any recent Linux or FreeBSD
distribution. For the 16 bit version you need the bcc tools from the
Embedded Linux Kernel Subset (ELKS) project, for more details see the
<url url="16.html" name="notes on 16 bit Etherboot">. You need the 16
bit version only if you intend to run Etherboot on a 286 or 086/088 PC.

<p>

Assuming you have decided to make the 32 bit version, you only have
to go to src/, edit the options in Config and say make. This will
create all the ROM images available in bin32. The .lzrom images are the
same as the .rom images. Since the .lzrom images are smaller and work
exactly the same, there is no real reason to use .rom images any more,
unless you are nervous about compression algorithm patents. We believe
the algorithm used does not infringe patents, having been in public use
for some time, but we do not know all the legal ramifications. See <url
url="COPYING_compressor.html" name="here"> for more details.

<p>

Here is a brief description of the options available:

<code>
Basic options:

-DNO_DHCP_SUPPORT-Use BOOTP instead of DHCP
-DRARP_NOT_BOOTP- Use RARP instead of BOOTP/DHCP
-DIMAGE_MENU	- Allow to interactively chose between different
		  bootimages; read vendortags.html for further
		  information.
-DMOTD		- Display message of the day; read vendortags.html
		  for further information.
-DASK_BOOT=n	- Ask "Boot from Network or from Local? " at startup,
		  timeout after n seconds (0 = no timeout); this
		  can be done in a more generic way by using the
		  IMAGE_MENU, but it requires that the "bootp"
		  server is accessible, even when booting locally.
-DANS_DEFAULT=ANS_NETWORK
		- Assume Network to previous question
		  (alternative: ANS_LOCAL) on timeout or Return key
		  See etherboot.h for prompt and answer strings.
-DEMERGENCYDISKBOOT
		- if no BOOTP server can be found, then boot from
		  local disk. The accessibility of the TFTP server
		  has no effect, though! So configure your BOOTP
		  server properly. You should probably reduce
		  MAX_BOOTP_RETRIES to a small number like 3.
-DNOINT19H	- Take control as soon as BIOS detects the ROM
		  Normally hooks onto INT19H
-DMOVEROM       - if your motherboard does not cache adapter memory
		  space, then this option can speed up loading of
		  compressed BOOT-Prom images. It has not affect on
		  uncompressed images. Unless you are very tight on
		  free space, you will usually want to define this
		  option.  This flag must be added to LCONFIG!
-DDELIMITERLINES - print a line of = characters at the start
		  and also just before starting an image.
-DSIZEINDICATOR - update a running total of the amount of code
		  loaded so far, in kilobytes
-DT509HACK	- send two bootp packets before waiting for a
		  reply to the first. Makes a 3c509 do bootp
		  quicker
-DT503_AUI	- Use AUI by default on 3c503 cards.
-DCONGESTED	- turns on packet retransmission.  Use it on a
		  congested network, where the normal operation
		  can't boot the image.
-DBACKOFF_LIMIT	- sets the maximum RFC951 backoff exponent to n.
		  Do not set this unreasonably low, because on networks
		  with many machines they can saturate the link
		  (the delay corresponding to the exponent is a random
		  time in the range 0..3.5*2^n seconds).  Use 5 for a
		  VERY small network (max. 2 minutes delay), 7 for a
		  medium sized network (max. 7.5 minutes delay) or 10
		  for a really huge network with many clients, frequent
		  congestions (max. 1  hour delay).  On average the
		  delay time will be half the maximum value.  If in
		  doubt about the consequences, use a larger value.
		  Also keep in mind that the number of retransmissions
		  is not changed by this setting, so the default of 20
		  may no longer be appropriate.  You might need to set
		  MAX_ARP_RETRIES, MAX_BOOTP_RETRIES, MAX_TFTP_RETRIES
		  and MAX_RPC_RETRIES to a larger value.

Etherboot/32 only options:

-DAOUT_IMAGE	- Add a.out kernel boot support (generic)
-DELF_IMAGE	- Add ELF kernel boot support (generic)
-DIMAGE_MULTIBOOT - Add Multiboot image support (currently only
		  for ELF images)
-DIMAGE_FREEBSD	- Add FreeBSD image loading support (requires at least
		  -DAOUT_IMAGE and/or -DELF_IMAGE)
-DCONSOLE_CRT	- set for CRT console (default if nothing else is set)
-DCONSOLE_SERIAL- set for serial console.
-DCONSOLE_DUAL	- set for CRT and serial console, see comment at
		  -DANSIESC and -DGFX
-DCOMCONSOLE	- set port, e.g. 0x378
-DCONSPEED	- set speed, e.g. 57600
-DCOMPARM	- set Line Control Register value for data bits, stop
		  bits and parity. See a National Semiconditor 8250/
		  16450/16550 data sheet for bit meanings.
		  If undefined, defaults to 0x03 = 8N1.
-DPASSWD        - enable password protection for boot images; this
		  requires -DIMAGE_MENU
-DUSRPARMS      - allow the user to interactively edit parameters
		  that are passed to the booted kernel; you should
		  probably enable -DPASSWD as well; this feature
		  requires -DIMAGE_MENU
-DANSIESC	- evaluate a subset of common ANSI escape sequences
		  when displaying the message of the day; this
		  probably does not make sense unless you also
		  define -DMOTD or at least -DIMAGE_MENU. It is
		  possible to combine this option with -DCONSOLE_DUAL,
		  but you have to be aware that the boot menu will
		  no longer use ANSI escapes to be compatible with the
		  serial console. Also be careful with your banners, as
		  they may confuse your serial console.  Gererally you
		  lose most of the ANSIESC functionality.
-DGFX           - support extensions to the ANSI escape sequences for
		  displaying graphics (icons or logos); this
		  requires -DANSIESC. It probably does not make sense
		  to use -DGFX if you have -DCONSOLE_DUAL, as the
		  serial console normally cannot handle the GFX stuff.
-DFLOPPY        - boot from floppy/hd if bootimage matches the
		  pattern "/dev/[fh]d*"; if you do not have
		  enough space in the EPROM, then disable this
		  feature and use "mknbi-blkdev" for booting
		  from a local blockdevice.
-DTRY_FLOPPY_FIRST
		- If > 0, tries that many times to read the boot
		  sector from a floppy drive before booting from
		  ROM. If successful, does a local boot.
		  It assumes the floppy is bootable. Requires -DFLOPPY.
-DCONFIG_PCI_DIRECT
		- define this for PCI BIOSes that do not implement
		  BIOS32 or not correctly
-DINTERNAL_BOOTP_DATA
		- define if the area 0x93C00-0x93FFF is not available
		  for use for bootpd_data by the loader for some reason

-DNO_DHCP_SUPPORT-Use BOOTP instead of DHCP
-DIMAGE_MENU	- Allow to interactively chose between different
		  bootimages; read vendortags.html for further
		  information.
-DMOTD		- Display message of the day; read vendortags.html
		  for further information.
-DASK_BOOT=n	- Ask "Boot from Network or from Local? " at startup,
		  timeout after n seconds (0 = no timeout); this
		  can be done in a more generic way by using the
		  IMAGE_MENU, but it requires that the "bootp"
		  server is accessible, even when booting locally.
-DANS_DEFAULT=ANS_NETWORK
		- Assume Network to previous question
		  (alternative: ANS_LOCAL) on timeout or Return key
		  See etherboot.h for prompt and answer strings.
-DEMERGENCYDISKBOOT
		- if no BOOTP server can be found, then boot from
		  local disk. The accessibility of the TFTP server
		  has no effect, though! So configure your BOOTP
		  server properly.  You should probably reduce
		  MAX_BOOTP_RETRIES to a small number like 3.

		  pattern "/dev/[fh]d*"; if you do not have
		  enough space in the EPROM, then disable this
		  feature and use "mknbi-blkdev" for booting
		  from a local blockdevice.
-DCONFIG_PCI_DIRECT
		- define this for PCI BIOSes that do not implement
		  BIOS32 or not correctly
-DINTERNAL_BOOTP_DATA
		- define if the area 0x93C00-0x93FFF is not available
		  for use for bootpd_data by the loader for some reason
</code>

<p>

You may also wish to examine file NIC for other options that may need
adjustment. If you find you need to adjust the PCI vendor and device IDs,
add the appropriate line to this file (and send me a copy). If you do
not set the IDs correctly, the floppy version will work, but the ROM
will not. The PCI IDs are usually displayed by the BIOS on booting
up. They can also be read out from a running Linux system using the
<url url="http://atrey.karlin.mff.cuni.cz/&tilde;mj/pciutils.html"
name="Linux PCI Utilities">.

<sect1>Testing the ROM images

<p>

You can test the image with a floppy before programming an EPROM. On
Linux just put a blank floppy in fd0 and say make bin32/card.fd0 where
card is the name of your network card and it will copy a bootable
image onto the floppy. If you wish to do this by hand, it's easy, just
make floppyload.bin.pre and prepend floppyload.bin.pre to card.rom
(or card.lzrom) and write this combined binary to the floppy raw,
i.e. starting at the boot block. Like this:

<p>

<code>
	cat floppyload.bin.pre 3c509.lzrom > /dev/fd0
</code>

When you boot with this floppy it will load the Etherboot ROM image from
floppy and execute it. It should be able to detect your card. To get
the bootrom to acquire an IP address and load the intended code, you
need to set up bootp, tftp and NFS services, which we will discuss next.

<p>

We suggest you continue to use floppy booting until you have completed
the setup of the server and are satisfied that diskless booting works.

<sect>Setting up a diskless boot

<p>

In this section I assume you want to boot a Linux kernel. Booting a
FreeBSD kernel will be documented soon.  Booting a DOS kernel is similar,
the main differences being in the way you set up the tagged image.

<sect1>Making a tagged image

<p>

Etherboot expects to download a <url url="spec.html" name="tagged image">
containing the code to be executed. Briefly explained, a tagged image
is a wrapper around the pieces of code or data that need to be put in
various places in the computer's memory. It contains a directory telling
how large the pieces are and where they go in memory. It also says where
to start execution.

<p>

A tagged image is created using a utility program. The <url
name="utility program" url="mknbi.html"> is specific to the kernel you
want to load. The version for Linux is called mknbi-linux and that for
DOS is mknbi-dos. These utilities are found in the mknbi directory of
the distribution.

<sect1>Compiling a custom kernel

<p>

You will almost certainly have to compile a custom kernel because the kernel
needs to have the "Root file system on NFS" option compiled in.  (You need to
select "NFS filesystem support" as built-in, not a module, and possibly also
"Kernel level autoconfiguration" before this option will appear.)  You should
also select "BOOTP support" and/or "DHCP support".  "RARP support" is not
needed.  In 2.2 kernels you have to enable the "Kernel level autoconfiguration"
option under IP networking to access the BOOTP support question.  And unless
you are using an initrd (initial ramdisk) you will have to compile in the
driver for your network card too. For details, see the file
/usr/src/linux/Documentation/nfsroot.txt in a Linux kernel source distribution.

<p>

After you have compiled the custom kernel, make the tagged image,
typically like this:

<code>
	mknbi-linux --output=/tftpdir/vmlinuz.xterm zImage
</code>

Then put the tagged image in where the tftp daemon expects to find it,
in this example /tftpdir. Make sure it is world-readable because typically
the tftp daemon runs as an unprivileged user. It is recommended that you
set a path explicitly for tftpd instead of relying on any defaults. For
example:

<code>
tftp	dgram	udp	wait	root	/usr/sbin/tcpd	in.tftpd /tftpdir
</code>

<sect1>Setting up a bootp daemon

<p>

Now set up a bootp daemon. In RedHat 5.2 this means installing the
bootp RPM package, making sure that the bootps service is active in
/etc/inetd.conf,  and editing /etc/bootptab. The essential pieces of
information you need to put in bootptab are:

<enum>

<item>The domain name of the machine.

<item>The Ethernet (MAC) address of the network card, which you generally
obtain from a sticker on the card, a configuration program for the card,
or in the last resort, from watching the output of Etherboot or from the
packets sent from the card when trying to boot, using the debug option
of bootpd.

<item>The name of the tagged image file, relative to the tftpdir
directory.

<item>The IP address you intend to give it.

<item>The IP addresses of various servers. You will need at least the
tftp server's address.

</enum>

<p>

Here is an example of a /etc/bootptab for the bootpd supplied with RedHat
Linux 5.2 and probably many versions of Unix:

<code>
.default:\
	:ht=ethernet:\
	:hd=/tftpdir:bf=null:\
	:ds=nameserver:\
	:hn:to=36000:
xterm.ken.net.au:tc=.default:ha=08002BB7F380:ip=192.168.26.100:bf=vmlinuz.xterm
</code>

The first entry sets up some common defaults which applies
to all succeeding entries which can be "included" using the
tc=.default attribute. The first field is the domain name of the
machine. The ha attribute is the Ethernet address.  The ip attribute is
self-explanatory. The bf field specifies the tagged image filename. For
more details, consult the bootptab man page.

<p>

Please note that if you use the ef (extension file) attribute to be
able to send more configuration data to the diskless machine, you must
run bootpef everytime bootptab is modified.

<sect1>Setting up a DHCP daemon

<p>

As an alternative to bootp, you could set up a DHCP server which has the
advantage of automating the handing out of IP addresses.  In RedHat 6.0,
bootpd is not supplied and DHCPD is preferred.  However the kernel will
still do a bootp request to find the IP address for mounting the NFS
filesystem. The exceptions to the last sentence are recent kernels in
the 2.2 series (2.2.15 or 2.2.16 onwards), which can autoconfigure using
DHCP thanks to code by Chip Salzenberg. It is rumoured that this feature
will not be ported to 2.4 kernels because DHCP autoconfig is a userland
issue. You may perhaps wish to investigate the --rootdir=rom option in
<url name="mknbi-linux" url="mknbi.html"> which tells the kernel to take
the address from the initial DHCP reply, or to use initrds in
conjunction with a userland DHCP client program to configure the
netbooted machine.

<p>

This is the roughly equivalent dhcpd.conf file to the above bootptab:

<code>
option domain-name "ken.net.au";
option domain-name-servers 192.168.26.1;
option broadcast-address 192.168.26.255;
use-host-decl-names on;
subnet 192.168.26.0 netmask 255.255.255.0 {
	filename "/tftpdir/vmlinuz.xterm";
	host xterm {
		hardware ethernet 08:00:2B:B7:F3:80;
		fixed-address xterm.ken.net.au;
		filename "/tftpdir/vmlinuz.xterm";
	}
}
</code>

You don't have to use fixed addresses, of course, but if you use
dynamic addresses, then you have to deal with the resulting issues of
NFS mounting.

<p>

More information about DHCP can be found at the <url
url="http://web.syr.edu/&tilde;jmwobus/comfaqs/dhcp.faq.html" name="DHCP FAQ
Web Page">.

<p>

If you are on a local network that is not directly
connected to the Internet, you can use the "private" IP
addresses 192.168.x.y (or in the other ranges mentioned in <url
url="http://ds.internic.net/rfc/rfc1918.txt" name="RFC1918">). Otherwise
please ask either your network administrator or your Internet service
provider for your own IP address(es).

<sect1>Setting up a tftp daemon

<p>

Now set up a tftp daemon. This means installing the tftp package and
making sure that the tftp service is active in /etc/inetd.conf. If you
want to be very careful You may wish to use the secure (-s) option of
tftpd, this chroots to the specified directory, but then your pathnames
in bootptab or dhcpd.conf must be relative to the new root directory.

<p>

If you are booting many clients you should be aware of the limitations
of running tftpd from inetd. Typically inetd has limits on how often a
daemon can be spawned, to detect runaway daemons. If many clients
request the tftp service within a short period, inetd may shutdown that
service.  If you have a setup where there are many clients, it may be
better to use a more flexible replacement for inetd, such as xinetd.
Another solution is to run a dedicated tftpd that is not spawned from
inetd. One such tftpd can be found here at:
<tt>ftp://nilo.on.openprojects.net/pub/nilo/snapshots</tt>

<sect>Testing the network booting

<p>

Now when you start up Etherboot, it should obtain an IP address and print
out what it received. If you do not get this to work, turn on debugging
in bootpd and see if any query was received. You may also wish to use
the tcpdump utility to watch the network for bootp packets.  If not,
check your network hardware (cables, etc). If a query was received,
check if bootpd was able to give an answer. If not, then the Ethernet
address was not found in /etc/bootptab. If a reply was sent, then only
faulty hardware or a bug in Etherboot would prevent it being received
by Etherboot.

<p>

Assuming an IP address was received, the next thing Etherboot tries to
do is load a file using tftp. Check your system logs to see if a tftp
daemon was started up and a file requested. Generally if you run tftpd
under tcpwrapper security, a log entry will be generated. If not, it
could be a path problem or file permission problem (the file needs to be
readable by tftpd). Another problem could be that tftpd needs to reverse
map the IP address to a name for security checking, and you don't have
the client's details in /etc/hosts or in DNS, or your tcpwrapper config
files (/etc/hosts.deny, /etc/hosts/allow) do not allow the access. Fix
the problem.

<p>

After the tagged image is loaded, Etherboot will jump to it. If it
crashes here, check that the image is a tagged image. If it executes
and stops at the point where it's trying to mount the NFS root,
then you need to check that you have the "root on NFS" option compiled
in and that you have compiled in the network card driver.

<sect1>Setting up a NFS root filesystem

<p>

Now you need to set up a NFS root filesystem for the diskless computer.
Typically this is under /tftpboot/&lt;ip address of computer&gt;. In
2.1 and higher kernels, this should be /tftpboot/&lt;name of computer
in bootptab&gt;.  This needs to contain a complete root filesystem
that will make the kernel boot happily.  This means, for most kernels,
it should contain /dev, /proc, /etc, /sbin, /bin, /tmp and /var. The
details vary from distribution to distribution.  Being lazy I just make
a copy of the necessary files from an existing RedHat 6.0 filesystem and
modify some key files appropriately. You can find a description in <url
url="diskless.html" name="my tutorial"> and some shell scripts to copy
the files. Since the amount of disk space needed is relatively small in
these days of large disks, I don't bother to throw out things that may
not be needed.

<p>

One thing to be aware of is that when you host the root filesystem on a
NFS server that is not Linux, the major and minor numbers of device files
will be different from what Linux is expecting, so the init process will
probably break just after it mounts the root NFS, maybe when it tries
to open the console device. You must create the root filesystem so that
it is Linux compatible, even though it is hosted on a different Unix.
One way might be to use cpio to capture a Linux root FS and then to
unpack on the target Unix system.

<p>

Warning: Do not attempt to reuse the root filesystem of your server,
whether by exporting it directly or by making hard links (symbolic links
will not work). First of all, the configuration files will contain
information pertaining to the server, not the client, so your client
will get the wrong information. Secondly, this is a security risk. NFS
is already not totally safe, but this way you are directly exposing your
server root to clients. Even if you make hard links, the clients could
(maliciously or accidentally) overwrite key binaries, making the server
unusable. Don't try to save a few megabytes of disk space this way. You
can however share some directories between clients, typically /sbin,
/bin and /lib.  The sample scripts in the tutorial show you how.

<p>

The root filesystem should be exported rw and no_root_squash because the
various processes need to be root and need to write to log files in the
root partition. You may wish to export /usr and /home filesystems to the
diskless computer also. These do not need no_root_squash permission. Be
aware that practically all Linux distributions have a few "bugs" relating
to symlinks and so forth for diskless booting.  These are mentioned in
the tutorial.

<sect1>Initial ramdisk

<p>

It is possible to use initial ramdisk (initrd) in addition to, or in
place of an NFS root. See the ramdisk argument of <url
name="mknbi-linux" url="mknbi.html">. You will also need to read the
Linux kernel documentation to see what extra arguments should be passed
to the kernel to make it use an initrd, and how to arrange the initrd so
that the startup script within it is called when it's mounted.

<p>

Initrds are useful for loading modules before the NFS root is mounted,
or to use some other network filesystem instead of NFS root, for
example.  Some applications could even run totally out of initrd,
provided you have the memory, of course. Also traffic on the kernel
mailing lists indicate that at some point in the future, kernel level
autoconfiguration (BOOTP/DHCP from the kernel) may be removed from the
Linux kernel and initrds may be the way to start up a diskless sytem
that can acquire an identity using a userland DHCP client program.

<sect1>Swap over NFS

<p>

Swap over NFS can be arranged but you have to patch the kernel source.
There are patches in the contrib directory for NFS swap but for up to date
patches, try <url url=" http://www.math1.rwth-aachen.de/&tilde;heine/nfs-swap/"
name=here>.

<p>

Be aware that opinions are divided on NFS swap.  Some people think
it's a bad thing because it just kills the network if you have lots
of diskless computers and that you shouldn't be running into a swap
regime on a diskless computer anyway. Some other people like having a
bit of insurance.

<p>

Also have a look at the <url
url="http://atrey.karlin.mff.cuni.cz/&tilde;pavel/nbd/nbd.html" name="NBD">
Network Block Device web page for swapping over that. This requires a
2.1 or 2.2 kernel.

<sect>Booting DOS

<p>

What about DOS? The deal with DOS is that one is loading a virtual
floppy called A: into extended memory and then booting from this floppy.
So you have to capture an image of a bootable DOS floppy first.  Some
more details can be found in the <url name="mknbi-dos" url="mknbi.html">
utility.

<p>

I have booted DOS (both M$ and DR versions) diskless this way.  A <url
name="mknbi-fdos" url="mknbi.html"> is available for building tagged
images for booting FreeDOS, the procedure differs slightly from booting
M$ or DR DOS. Note that extended memory is used so that rules out
086/088 computers but 286s are ok. See <url url="atnetboot.html"
name="this document"> for more details.

<p>

If you were thinking of booting a Windows machine via the network,
it seems (I'm not masochistic enough to do this) the problem is not
the network booting but the mounting of a file system over NetBIOS
(Windows does not do remote mounts of root filesystems over NetBIOS on
TCP). So that rules out a Samba server. It appears to be possible over
a Netware server, for which Linux or FreeBSD has workalikes. But then
what do you do about the networking stack? This situation may change
with with future Samba developments. But you will still have problems
with pathnames and the usual Windows hassles. Do you really want to
do this?  You do know that you can run lots of desktop applications like
Netscape, StarOffice, etc. on Linux, FreeBSD, etc. now?  In the <url
url="http://etherboot.sourceforge.net/" name="Web page for Etherboot">,
there are links to external Web pages, one explaining how this was done
with a commercial TCP/IP boot ROM, another explaining how to do it using
Etherboot and Netbios over IPX. Good luck and send us your experiences
or better still a URL to a page explaining how you did it.

<sect>Making an Etherboot EPROM or EEPROM

<p>

Assuming you have satisfactorily set up your server environment, you
may now wish to put the Etherboot onto an EPROM or EEPROM. Naturally
this assumes access to hardware to program (and possibly erase) EPROMs.
An alternative is to use an EEPROM card. There is a schematic and PCB
artwork for such a card at the web site where you got the Etherboot
distribution. This EEPROM card plugs onto the ISA bus and can be
reprogrammed with software. Some network cards, for example the 3Com
905B, have a socket for an EEPROM which can be programmed in situ with
the right utilities. See any release notes accompanying Etherboot for
more information.

<sect1>Choosing the EPROM

<p>

Most network cards come with a blank (E)EPROM socket even though it is
seldom used. When it is used, it is typically filled with a proprietary
EPROM from the network card manufacturer. You can put an Etherboot
EPROM there instead.

<sect1>Enabling the EPROM

<p>

First you must discover how to enable the EPROM socket on your
card. Typically the EPROM is not enabled from the factory and a jumper
or a software configuration program is used to enable it.

<sect1>Size and speed of the EPROM

<p>

Secondly, you must discover what size and speed of EPROM is needed. This
can be difficult as network card manufacturers often neglect to provide
this information.

<p>

The smallest EPROM that is accepted by network cards is an 8k EPROM
(2764). 16kB (27128) or 32kB (27256) are the norm. Some cards will even
go up to 64kB EPROMs (27512). You want to use the smallest EPROM you
can so that you don't take up more of the upper memory area than needed
as other extensions BIOSes may need the space.  However you also want
to get a good price for the EPROM. Currently the 32kB and 64kB EPROMs
(27256 and 27512) seem to be the cheapest per unit. Smaller EPROMs appear
to be more expensive because they are out of mainstream production.

<p>

If you cannot find out from the documentation what capacity of EPROM your
card takes, for ISA NICs only, you could do it by trial and error. (PCI
NICs do not enable the EPROM until the BIOS tells the NIC to.)  Take a ROM
 with some data on it (say a character generator ROM) and plug it into the
socket. Be careful not to use an extension BIOS for this test because it
may be detected and activated and prevent you from booting your computer.
Using the debug program under DOS, dump various regions of the memory
space. Say you discover that you can see the data in a memory window
from CC00:0 to CC00:3FFF (= 4000 hex = 16384 decimal locations). This
indicates that a 16kB EPROM is needed. However if you see an alias in
parts of the memory space, say the region from CC00:0 to CC00:1FFF is
duplicated in CC00:2000 to CC00:3FFF, then you have put an 8kB EPROM
into a 16kB slot and you need to try a larger EPROM.

<p>

Note that because pinouts for 28 pin EPROMs are upward compatible after a
fashion, you can probably use a larger capacity EPROM in a slot intended
for a smaller one. The higher address lines will probably be held high
so you will need to program the image in the upper half or upper quarter
of the larger EPROM, as the case may be. However you should double check
the voltages on the pins armed with data sheet and a meter because CMOS
EPROMs don't like floating pins.

<p>

If the ROM is larger than the size of the image, for example, a 32
kB ROM containing a 16 kB image, then you can put the image in either
half of the ROM. You will sometimes see advice to put two copies of the
image in the ROM. This will work but is not recommended because the ROM
will be activated twice if it's a legacy ROM and may not work at all
if it's a PCI/PnP ROM.  It is tolerated by Etherboot because the code
checks to see if it's been activated already and the second activation
will do nothing. The recommended method is to fill the unused half with
blank data.  All ones data is recommended because it is the natural state
of the EPROM and involves less work for the PROM programmer. Here is a
Unix command line that will generate 16384 bytes of 0xFF and combine it
with a 16 kB ROM into a 32 kB image for your PROM programmer.

<code>
	(perl -e 'print "\xFF" x 16384'; cat 3c509.lzrom) > 32kbimage
</code>

<p>

The speed of the EPROM needed depends on how it is connected to the
computer bus.  If the EPROM is directly connected to the computer bus,
as in the case of many cheap NE2000 clones, then you will probably have
to get an EPROM that is at least as fast as the ROMs used for the main
BIOS. This is typically 150 ns. Some network cards mediate access to
the EPROM via circuitry and this may insert wait states so that slower
EPROMs can be used. Incidentally the slowness of the EPROM doesn't affect
Etherboot execution speed much because Etherboot copies itself to RAM
before executing. I'm told Netboot does the same thing.

<sect>Troubleshooting tips

<p>

<itemize>

<item>Floppy boot doesn't work. Have you copied the ROM image (with
the floppyloader prepended) to the floppy raw? Is that size of floppy
bootable by your computer? Are you trying to run a 32 bit Etherboot
on a 16 bit machine (286, 086/088)? Have you selected too many compile
time options? The real limit on Etherboot is not the size of the EPROM
but the fact that it executes in the 32kB region between 0x98000 and
0xA0000. If the sum of code, stack and bss is greater than 32kB, then
Etherboot might crash at unexpected places. You could increase the memory
to 48kB by lowering the RELOCADDR in the Makefile but this is outside the
specifications. Definitely do not lower RELOCADDR below 0x94000 because
various pieces of booting information are stored from 0x90000 upwards.

<item>Floppy version works but EPROM version doesn't work. There is
a program called rom-scan (Linux, FreeBSD and DOS versions) in the
directory contrib/rom-scan which will help detect problems.

	<itemize>

	<item>If the EPROM is not detected at all then the contents of
	the EPROM are not visible to the BIOS. Check that you have enabled
	the EPROM with any jumpers or soft configuration settings. Check
	that you do not have any conflicts in the memory address of
	the EPROM and any other hardware.  Perhaps you have to prevent
	it from being mapped out by your BIOS settings. Or perhaps you
	have to shadow it with RAM. Maybe you put the code in the wrong
	half or wrong quarter of the EPROM. Maybe the access time of
	the EPROM is not low enough. You can also use the debug program
	under BIOS to examine the memory area in question.

	<item>If rom-scan says the EPROM is present but not active,
	then something prevented the BIOS from seeing it as a valid
	extension BIOS. This could be truncation of the EPROM window,
	maybe you have a larger EPROM in a slot meant for a smaller
	one. Maybe there is a checksum error in the EPROM due to
	some bits not properly programmed or the EPROM not being fast
	enough. In one case that we know of, the 3c503 network card,
	the ASIC actually returns 2 bytes of 80 80 in the end locations
	of the EPROM space. This apparently is a kind of signature. The
	makerom program in Etherboot compensates for this, but if the
	pattern is not 80 80, then the code needs to be modified.

	<item>If rom-scan says the EPROM is present and active, but
	BIOS does not see it, then perhaps the EPROM is located in an
	area that the BIOS does not scan. The range scanned is supposed
	to be 0xC0000 to 0xEF800 in increments of 2kB but I have seen
	some BIOSes that continue the scan into the 0xF0000 page.

	</itemize>

Note that rom-scan will also detect other extension BIOSes mounted on your
computer, for example VGA BIOSes and SCSI adapter BIOSes. This is normal.

<item>Etherboot does not detect card. Are you using the right ROM
image? Is the card properly seated in the computer? Can you see the
card with other software? Are there any address conflicts with other
hardware? Is the PCI id of the card one that is not known to Etherboot
yet? In this case and where you think there is a bug in Etherboot,
please contact the author with all details.

<item>Etherboot detects card but hangs computer after detection. Some
cards are booby traps while they are enabled. The typical offenders
are NE2000s which will hang the bus if any access is made to the reset
addresses while interrupts are active. You may need to do a hard reset
of the computer, i.e. power down and up again before running Etherboot.

<item>Etherboot detects card but does nothing after saying Searching for
server. Check your network hardware. Did you select the right hardware
interface (AUI, BNC, RJ45)? Is the cabling ok? If you have a Unix computer
on the network and have root privileges, you could run tcpdump looking
for broadcast packets on the bootps port. If the requests are getting
sent out but no replies are getting back, check your bootpd setup. Also
check if the server has a route to the client.

<item>Etherboot obtains IP address but fails to load file. Check the tftp
server. Is the tagged image file installed? Is the file world readable? Is
the path to the file allowed by the configuration of tftpd? Is the client
denied by tcpwrapper rules?  Did you put the right home directory and
boot filename in bootptab? If you are booting lots of clients, is inetd
shutting down tftpd for being spawned too often? If so, you need to get
a dedicated tftpd that runs as an independent daemon.

<item>Etherboot loads file via tftp but Linux fails to boot. This is a
large category. Here are some suggestions:

	<itemize>

	<item>You do not have a private copy of the /, /etc, /var,
	... directories

	<item>Your /dev directory is missing entries for /dev/zero and/or
	/dev/null or is sharing device entries from a server that uses
	different major and minor numbers (i.e. a server that is not
	running Linux).

	<item>Your /lib directory is missing libraries (most notably libc*
	and/or libm*) or does not have the loader files ld*.so*

	<item>You neglected to run ldconfig to update /etc/ldconfig.cache
	or you do not have a configuration file for ldconfig.

	<item>Your /etc/inittab and/or /etc/rc.d/* files have not been
	customized for the clients.

	<item>Your kernel is missing some crucial compile-time feature
	(such as NFS filesystem support, booting from the net, transname
	(optional), ELF file support, networking support, driver for
	your ethernet card).

	<item>Missing init executable (in one of the directories
	known by the kernel: /etc, /sbin, ?). Remember /sbin/init must
	be a real file, not a symlink.

	<item>Missing /etc/inittab

	<item>Missing /dev/tty?

	<item>Missing /bin/sh

	<item>System programs that insist on creating/writing to files
	outside of /var (mount and /etc/mtab* is the canonical
	example)

	</itemize>

The essence is that you must provide whatever is needed in the NFS root
filesystem that your kernel needs to boot. This is somewhat distribution
dependent. In the discussion mentioned above I solved the problem by
making a copy of an existing root filesystem and modifying a few bits.
Be aware that some, if not all, distributions contain bugs in their layout
that hinder diskless mounting so you will have to fix any problems that
arise. An example was a directory in /usr/X11R6/lib that needed to be
writable, however /usr was mounted read-only. Another common problem
is the assumption that /usr is available before NFS mounts are done and
invoking programs stored there.

<item>Etherboot works fine and kernel starts but network interface
doesn't work. Check your network configuration in the OS.  Etherboot uses
polled I/O and not interrupt I/O to fetch the images. So the IRQ line
doesn't get exercised. This manifested itself in one case with a NIC
that could netboot but network programs run afterwards couldn't receive
any packets. It seemed to be a combination of a weak NIC IRQ line and
a fussy motherboard. But the same thing could happen if say the IRQ is
not set to where the software is expecting it. The image will load fine
with the wrong IRQ but the software will not run properly. This is more
of an issue with say DOS packet drivers, where the user has to specify
the IRQ line than with Linux, which autoprobes.

</itemize>

<p>

<sect>Frequently Answered Questions

<p>

Contributions are invited for this section. Mail them to <url
url="mailto:ken_yap@users.sourceforge.net" name="me">.

<sect1>Building Etherboot

<p>

<enum>

<item>What do I need to build Etherboot?

<p>

You need gcc, gas and objcopy, as well as any accompanying libraries and
include files. Generally speaking on a package based system using RPM
or PKG, you will need the C compiler package, the include file package,
the C library package, the assembler package and the binutils package
(this may include the assembler). In addition, if you intend to modify
the assembler files you will need an up-to-date as86 and ld86, not the
ones that come standard with Linux, but from the ELKS project; or you
will need nasm. You will also need perl if you modify the file `NIC' or
use a different RELOCADDR value in the Makefile than the default, and
m4 if you modify this file `README.xsgml'.

<item>I get an error from as saying `data32' is an unknown directive.

<p>

Your gas is too old, upgrade to 2.9.1 at least.

<item>I get an error from as saying `data32' (and others) should be
prefixes.

<p>

Support for extended directives changed in syntax between gas 2.9.1 and
gas 2.9.5. Disable -DGAS291 in Config to allow for the new syntax. In
recent versions of Etherboot, this should be automatically detected.

<item>The documentation talks about `mknbi-linux' and `mknbi-dos'. Where
are they?

<p>

These are <url name="utilities" url="mknbi.html"> in the mknbi-1.0
directory.  You need to cd into this directory, edit Makefile and run
make and make install to install the utilities in their final location.

<item>Why don't you provide prebuilt ROM images?

<p>

Etherboot is constantly updated, and binary images would get out of
date soon.  Binaries can lose any external indication of what release
they were from. Old binaries might float around and create problems for
users who are not aware that bugs have been fixed in newer versions. Also
there are some user configurable options you might want to change.
For this reason, Etherboot is provided in source form for you to build.

</enum>

<sect1>Testing Etherboot

<p>

<enum>

<item>I put the ROM image on floppy like you wrote (cat floppyload.bin.pre
bin32/foo.rom > /dev/fd0, or make bin32/foo.fd0) but the floppy prints
out hex numbers when it boots.

<p>

The floppy you use should be an error-free, preferably a recently
formatted floppy. Do not trust new floppies; they have been known to
lose their manufacturer formatting in storage. You don't need to put a
filesystem of any sort on it, FAT or ext2 or otherwise. Another possible
cause is that there are alignment differences between the drive used to
write the floppy and that used on the target machine. As far as I know
the floppy boot should work on all floppy sizes (1.44M, 720k, and even
1.2M and 360k if you can still find these), but beware of differences
between drives, e.g. writing a 360k floppy in a 1.2M drive creates narrow
tracks which may not overwrite previous contents.

<item>My network adapter is detected but I get no reply to the
BOOTP/DHCP request.

<p>

Do you have a BOOTP or DHCP server running on the same Ethernet segment?
On many operating systems the server is not enabled by default. Review
the instructions in the Troubleshooting section. Another thing to
note is that the BOOTP (or DHCP in fixed address mode) server will not
reply if it does not know the network adapter's Ethernet address. Since
the address may be hard to determine if it is not printed on the card
or you do not have the adapter's setup program, you can copy it from
Etherboot's startup message. Remember to restart the server if you have
edited the config file and the server does not automatically reread when
it discovers an updated config file.

<p>

Another thing to check is that the BOOTP or DHCP server is allowed
to receive the query. You may have some protection mechanism such as
tcpwrappers in front of it. As the booting computer does not have an
IP address, the request will come from 0.0.0.0 so your rules must allow
through packets from this address.

<p>

If the BOOTP or DHCP server is on another Ethernet segment, things
get more complicated. You need to run a BOOTP or DHCP relay. You will
probably also need to set the gateway field in the reply so that TFTP
will work across the gateway. You should read a good explanation of how
these work, in say, W. Richard Steven's book `TCP/IP Illustrated'.

<item>Etherboot gets the BOOTP/DHCP parameters but cannot find a
TFTP server.

<p>

Do you have a TFTP server running and is it allowed to serve the client
in question? For example the tcpwrapper rules may not allow TFTPD to
respond to the IP address the booting computer is at. You should look
at the log files on the server for any clues.

<item>The TFTP server is found but it replies `Access violation'.

<p>

Access violation is a blanket reply for many different problems but
essentially the TFTP server cannot give Etherboot the file requested. Did
you put the file where TFTPD expects to find it, e.g. on a directory
that is on its path? Did you make the file world readable? Case of the
filename is important too.

<item>I made this kernel and put it in /tftpdir like you
wrote but Etherboot says `Unable to load file'.

<p>

Is the file a tagged image? You cannot use a ordinary kernel image, you
must process it with <url name="mknbi-linux" url="mknbi.html"> first.

<item>I have this proprietary boot ROM and I used mknbi-linux to make a
tagged image, (or I got this tagged image from the LTSP project), but
the boot ROM doesn't load it, or it fails to run.

<p>

Tagged image format is specific to Etherboot and Netboot. It will
not work with proprietary boot ROMs. You have to find out from the
supplier what boot procedures you should use. For example, if you are
using a Lanworks boot ROM, the infomation you need is <url name="here"
url="http://www.3com.com/managedpc">.

<item>Why don't you use some standard format instead of tagged image
format?

<p>

First of all, tagged image format actually precedes many of the
proprietary formats in use today. So we were there first. Secondly
there is no acknowledged standard for the boot image format, although
there are some contenders now. Perhaps some day there will be an open,
widely-accepted format. Until then you have to aware that there are
different ones out there.

</enum>

<sect1>Hardware capabilities

<p>

<enum>

<item>What network cards are supported?

<p>

See an earlier section in this README document.

<item>I have a machine with the X processor and Y megabytes of memory.
What can I expect to run on it?

<p>

Please note that these estimates are approximate:

<itemize>

<item>On a 8088/8086 you can only boot ELKS, a 16-bit mini-version of
Linux, since 0.0.83 there has been support for making a tagged image
and a ramdisk. However there are few applications for ELKS. For more
details please go to the ELKS web site and mailing lists. Note that
there is no networking in ELKS yet.

<item>On a 286 you can run DOS. With 384kB of extended memory you can
run a 320kB ramdisk that can hold NCSA telnet with a VT100 terminal
emulation. With about 720kB of extended memory you can run DOS Kermit,
which has telnet capabilities and a VT320 terminal emulation. You can
run various small application and network services. See <url name="the
AT netbooting document" url="atnetboot.html"> and <url name="the 16-bit
HOWTO" url="16.html"> for some ideas.

<item>On a 386 with at least 4MB of memory you can boot Linux. With 4MB
perhaps only a few telnet sessions are possible. With 8MB you might be
able to run a text based web browser like Lynx or W3M.

<item>On a 486 with 16MB of memory you can run X to make an X-terminal.

<item>On a Pentium with 32MB of memory you can run an X-terminal and
some applications locally, say perhaps printing, daemons to control
devices, etc.

<item>On anything faster and with more memory you could perhaps do
distributed computation, e.g. a Beowulf cluster.

</itemize>

</enum>

<sect1>Booting Linux

<p>

<enum>

<item>The kernel loads but it cannot configure the network device.

<p>

Did you compile the network adaptor driver into the kernel? Is the
network adaptor at an address that is probed by the driver? If not,
perhaps you need to provide some kernel parameters to help it find the
hardware.

<item>The kernel loads but it cannot mount a root filesystem, then it
asks me to insert a floppy.

<p>

Did you build the kernel with the root on NFS option? You cannot use
a stock kernel from a distribution.

<item>The kernel loads but it cannot find a NFS server for the root
filesystem.

<p>

Do you have a NFS server running and is it allowed to serve this client?
NFS is actually several services. On Linux at least you need: nfsd (either
kernel or userland version), rpc.mountd and portmapper. Check if the
tcpwrappers config file is allowing portmapper to receive the request.
Look at the log files for clues. Did we already mention that log files
are your friends?

<item>The root filesystem mounts but it says something about not being
able to open an initial console. Or alternatively, various services
complain about not being able to write to the filesystem.

<p>

Please review the Troubleshooting section for what is required on this
root filesystem. The situation is complicated by the fact that there are
many possible ways of setting this up, including using a root filesystem
that is on ramdisk. If you wish to avoid many of the troubles, try using
a packaged solution such as <url name="LTSP" url="http://www.ltsp.org/">
or my shell scripts for creating a root filesystem by copying files from
an existing distribution.

<item>What is the recommended way of setting up the NFS root?

<p>

There is no one true way, but several approaches. Network booting is a
tool and a very flexible one.  Here are just a few suggestions:

<enum>

<item>You can make a separate NFS root for each client, but share the
sharable files between clients using hard links to minimise disk space
requirements. This is the approach I took in <url url="diskless.html"
name="my tutorial">. I used this because I was lazy, I have only a
couple of diskless clients and I could copy the files from an existing
distribution.

<item>You could use the packaged solution from <url name="LTSP"
url="http://www.ltsp.org/">, which creates a shareable NFS root for
multiple clients.

<item>August H&ouml;randl describes <url name="his approach"
url="http://elina.htlw16.ac.at/~hoerandl/nfs-root/"> which uses a ramdisk for
the initial startup, and then merges in a readonly NFS filesystem.

<item>It is rumoured that the <url name="Debian distribution"
url="http://www.debian.org/"> has a package called diskless that
contains Perl scripts to create such a filesystem.

</enum>

<p>

If you have an approach which you think the world should know about,
please send the URL of a web page that describes it to <url name="me"
url="mailto:ken_yap@users.sourceforge.net">.

</enum>

<sect1>Running X

<p>

<enum>

<item>I tried to run X on the client but it aborted.

<p>

Remember that the config files used by the X server should pertain
to the client's video adapter and display hardware. If you used a
<url name="LTSP" url="http://www.ltsp.org/"> package, please review
the configuration directions. If you used the `copy files from server'
solution, then you need to customise the X server configuration. Another
thing that may cause the server to abort is lack of a mouse device.

<item>X -query server runs but all I get is a gray stippled screen.

<p>

Either you don't have an XDM server running on the server machine or
it is not allowed to serve this client. In the latter case check XDM's
Xaccess file, because for security reasons, the ability for clients to
connect is usually disabled.

<item>When I am logged in using an X-terminal, I find that the floppy
drive, sound card and name of the computer are those of the server!?

<p>

This is to be expected! This is exactly how an X-terminal works. You
are indeed logged onto the server and the client just provides
display (screen) and input device (keyboard and mouse) services to the
application. This is one of the beauties of the X Windowing system model,
it's <it>network transparent</it>.

<item>So how do I run applications on the client? I have this (smartcard
reader, printer, sound card, etc) program that must execute locally.

<p>

Some client configurations allow you to run applications locally, in
addition to running them on the server. In fact the printer and sound
daemons mentioned later are applications that are run on the client.

<item>X applications cannot find (some) fonts.

<p>

Do you have an X font server (XFS) running on the server machine, is it
allowed to serve this client, and has the client been told to use the
font server? The last point is usually configured in the XF86Config file,
or by a xset command to modify the font path after logging in.

<p>

Also note that RedHat (and possibly other distributions) has made XFS
by default serve only the local machine using a Unix socket.  You need
to modify the startup script to tell XFS to use a TCP/IP socket.

<item>How much CPU power and memory do I need on the client? On the
server?

<p>

It depends on the configuration. There are two major cases: where the
client is an X-terminal, and not much more; and where the client is
configured to run applications locally.

<p>

An X server will fit in 16MB of memory, and 32MB is quite adequate.
Performance depends on the CPU, video card and your expectations.
An old Pentium 200 with a PCI video card does very well, but if you are
not fussy, a high-end 486 with a VLB video card can be satisfying too.

<p>

If you want to run apps locally, well how long is a piece of string?
Netscape will need say another 16MB. It all depends. Whatever you do,
it's worth trimming down on the services you run on the client. Don't
run more virtual consoles than you need and don't run unneeded daemons.

<p>

As for the server, in the X-terminal case this has all the applications
running on it, so it should be adequate for the multiuser aspect. A
high-end Pentium, with 64 MB of memory to start with, and between 8 and
16MB for each extra client is a good starting point. It will also depend
on your mix of client access, statistically perhaps not everybody will
be running at the same time. Remember that you don't have to have one
big server for all your clients, you can and you should distribute the
load across servers.

</enum>

<sect1>Other client applications

<p>

<enum>

<item>How can I print to a printer attached to a diskless client?

<p>

There is a server program called p910nd at the Etherboot site (and
improved versions of it at <url name="LTSP" url="http://www.ltsp.org/">)
that funnels data from a TCP/IP connection to the printer port. You
can instruct lpd or <url name="CUPS" url="http://www.cups.org/"> on the
server to send jobs across the network to p910nd.

<item>How can I output sound on the client?

<p>

There is a package called <url name="virtualfs"
url="http://www.solucorp.qc.ca"> that proxies the sound devices across
the network. It can also proxy the floppy drive.

<p>

Another solution is <url name="EsounD"
url="http://www.tux.org/&tilde;ricdude/EsounD.html">

<item>How can I access the floppy on the client?

<p>

Besides virtualfs mentioned above, recent distributions of <url
name="mtools" url="http://wauug.erols.com/pub/knaff/mtools/"> have a
floppyd. This only works with the mtools utilities though.

</enum>

<sect1>Booting FreeBSD

<p>

<enum>

<item>Where are the instructions for booting FreeBSD?

<p>

For now, there is just a short document in the doc directory. Better
versions of this document depend on contributions from the FreeBSD
community, I am unable to test FreeBSD because I don't run it.

</enum>

<sect1>Booting other operating systems (DOS, Windows)

<p>

<enum>

<item>I want to boot FreeDOS.

<p>

The new mknbi utility supports creating tagged images from FreeDOS
kernels now.  See the <url name="man page" url="mknbi.html"> for
details.  FreeDOS is a moving target and the layout of the kernel image
or other things may have changed so you would need to be well acquainted
with FreeDOS. Please send any corrections to me.

<item>I cannot boot DR-DOS 7.03.

<p>

There is some difference between the DR-DOS 7.03 and 7.02 bootblock that
causes it not to boot. But a 7.02 bootblock works just as well with the
DR-DOS 7.03 kernel, so you can substitute that. There are instructions
to extract the bootblock in the <url name="AT netbooting document"
url="atnetboot.html">.

<item>DOS dies when I load HIMEM.SYS.

<p>

Use the /testmem:off option to prevent HIMEM from scribbling over the
ramdisk which is the `floppy' A:.

<item>How do I make A: my real floppy again after booting is complete?

<p>

Use the rmrd.com program supplied with <url name="mknbi-1.0"
url="mknbi.html">.

<item>I want to use the real floppy at the same time I am using the
ramdisk image of the boot floppy.

<p>

The --harddisk option of mknbi is intended for this. It causes your boot
drive to be C:, so you can use A: for the real floppy. See the <url
name="man page" url="mknbi.html"> for more details

<item>I want to boot Windows.

<p>

I pass on this one, as I do not have (by choice) any Windows systems
running on my computers. Perhaps others can contribute to this
section. However I gather that it is only possible on Windows95A, as
other versions don't have the necessary support for diskless booting.

</enum>

<sect1>Hardware issues

<p>

<enum>

<item>Where can I get an EPROM made?

<p>

Depending on where you live, you might find a supplier listed on the
Commercial Links page. Another possibility is to get the help of someone
working in a university or industrial lab who has an EPROM programmer.
If you are handy with hardware, you could buy a kit or build your own.
There are links to kit suppliers in the Commercial Links part of the
home page.

<p>

Some high end adapters, for example the 3Com and Intel ones, accept
an EEPROM in the socket. This can be programmed in-situ using utility
programs, some of which or information about are under the contrib
directory in the Etherboot distribution.

<p>

Finally some recent motherboard have flash BIOSes which contain
space where an extension BIOS such as Etherboot can be inserted. The
Phoenix Award BIOSes can be modified using a program called cbrom.exe
possibly <url name="here" url="http://www.ping.be/bios">. It
is also reputed to live <url name="here"
url="http://www.boardrunner.com/download/utility/utility.htm">. Or do a
Web search for it.  No success has been reported for AMI BIOSes. Dirk von
Suchodoletz maintains a list of successes and failures <url name="here"
url="http://goe.net/anleitungen/award_board.html">.

Here is some text contributed by Dirk von Suchodoletz. He hopes to put
it on a web site someday:

<code>
6.4 Using your mainboard's BIOS to integrate etherboot-code

Newer mainboards that have an AWARD-BIOS can use etherboot without
seperate EPROMS and therefore without the necessity of having a
EPROM-programmer[?]. (Heinrich Rebehn wishes to add: Flashing the BIOS
is always a (small) risk. Flashing with unsupported, hacked BIOS image
is *dangerous* and may render your PC unbootable.  If you don't
have access to a PROM burner you should stay away from experimenting.) In
order to do this, you need 2 software tools: awdflash.exe, which should be
included in your mainboard package, and cbrom.exe, which is an OEM-tool
that allows modifications of the BIOS. awdflash.exe reads and writes
the flashrom content, whereas cbrom.exe is used to analyze the content
of the AWARD BIOS image. cbrom.exe can also add code to the BIOS image
or remove components.  This way you can easily integrate etherboot into
your mainboards without even opening the PC's case.

After the BIOS image has been saved (e.g. as bios.bin), or in case the
current version of the BIOS has been copied from the board manufacturer's
website, 'cbrom bios.bin /d' shows how much space is left on the image
for your code.

As the flashrom holds the compressed BIOS, cbrom will also compress
the code when adding it to the BIOS.  Therefore, 8 to 20 kbyte of free
memory is needed, depending on the network adapter's driver. In case not
enough memory is left, unneeded BIOS components can be removed from the
BIOS image to regain space: the manufacturer's logo or the Symbios/NCR
SCSI-code are note needed for diskless systems. 'cbrom bios.bin
/[pci|ncr|logo|isa] release' will remove those unnessary components.

The command line "cbrom bios.bin /[pci|isa] bootimg.rom [D000:0]" adds
the compiled etherboot code to the bios. bootimg.rom is the code we
would use to burn onto EEPROMs in other cases. Depending on your network
card, either the pci or isa options have to be used. With isa cards
you have to tell cbrom to which RAM location the code will be extracted
at boot time. Attention: Compile the etherboot with the -DASK_BOOT or
-DEMERGENCYDISKBOOT option to be able to access a disk. The code added
by cbrom will be executed before the computer seeks for a boot disk
or floppy.

6.5 Booting with a DOS executable (COM) file

If the computer has to be used with more than one operating systems,
for example using the computer as an X-Terminal in addition to the
already installed NT on the harddrive, etherboot has to be used with
the compile-time option -DASK_BOOT. In case hardware-conflicts beetween
Windows NT and the installed EPROM exist, creating DOS Executables
(e.g. using 'make rtl8139.com') can provide a useful remedy. Those DOS
Executables are comparable in their functionality to .rom images and
can be used as substitutes.

In case an existing DOS-bootsector, stored in BOOTSECT.DOS, cannot be
used, creating one has to be done by formatting and installing a harddrive
using DOS before installing NT (see Win-NT Multiboot-HOWTO). In addition
the DOS system files are needed (IO.SYS, MSDOS.SYS, or KERNEL.SYS
when using Freedos) and have to be copied into the directory of the
NT loader. If using Autoexec.bat to start the .COM file is desired,
either the particluar COMMAND.COM has to be provided or the etherboot
file needs to be renamed as COMMAND.COM. This file will then be started
instead of the DOS-Shell which is useful for avoiding unwanted user
interaction. Afterwards a line has to be added to BOOT.INI as if DOS
was to be booted:

[boot loader]
timeout=20
default=C:\bootsect.dos #add this line if dhcp/tftp should be default action
[operating systems]
multi(0)disk(0)rdisk(0)partition(2)\WINNT="Windows NT Workstation, Version 4.0"
[VGA-Modus]" /basevideo /sos
C:\bootsect.dos="DHCP/TFTP (Linux diskless via etherboot)" #our boot option
</code>

And here are some comments by Rapp Informatik Systeme GmbH about
cbrom.exe versions:

<code>
Some  more remarks  for cbrom..

There are several version numbers of cbrom.exe  p.e. 1.x  and 2.x.
and there is a cbrom called cbrom6.exe.  First cbrom.exe with Version
1.x  (newest 1.32)  is for Award Bios Version 4.5x   and cbrom6.exe is
for Award Bios Version 6.xx.

So because it seems a lot people become confused  and use cbrom 1.x
for the new 6.x  Bios Award merged this together  to a cbrom.exe   with
Version number 2.x ( newest know 2.04) witch now runs on Award 4.5x and
6.xx Bioses.

Now how to find cbrom.exe.  Different  1.x Versions  of cbrom.exe
could be found  on the net, cbrom6.exe  seems to be gone.  It seems
that Award/Phoenix do all that cbrom is deleted from servers of board
manufaktures.  So cbrom.exe Vers 2.04  is not  available on the net.
If  somebody need this please try to send a demand question to the list -
I hope somebody will mail it to you.
</code>

<item>How do I enable the ROM socket on my network adapter? There are
no jumpers on the card.

<p>

These jumperless cards need a card-specific utility program to enable
the ROM. Normally the manufacturer supplies it on a diskette or CDROM.
You lost the diskette? If you know the manufacturer, you might be able
to get the program from their website. You have a mystery card? Well the
first thing to do is to identify the card. If it is an ISA card and made
in Taiwan or China it's almost certainly a NE2000 clone. For some
information, try <url name="here"
url="http://members.nbci.com/ken_yap/NIC/">.

<item>I would like to boot my laptop diskless from a floppy containing
Etherboot.

<p>

The problem is that laptops these days use PCMCIA network adapter cards.
These in turn connect to the PCMCIA controller when docked. To be able to
communicate with the PCMCIA card, Etherboot would first have to `talk'
to the PCMCIA controller. Until somebody writes the code to do this...
Booting from disk is different because the kernel will load the PCMCIA
controller code from disk first. You could always put a Linux kernel on
the boot floppy.

</enum>

<sect1>Drivers

<p>

<enum>

<item>There is no Etherboot driver for my network adapter. Can you write
me one?

<p>

If I were independently wealthy and had nothing else to do in life, sure!
But unfortunately I have a day job and Etherboot is a hobby. A couple
of the drivers were written for pay and the others were written by
volunteers. Perhaps you might like to volunteer?  If you have a good
grasp of C, and understand basic hardware concepts, it is quite doable,
and not nearly as difficult as writing a Linux device driver.  See the
section on <ref name="Writing an Etherboot Driver" id="driver">. You
will have the reward of understanding hardware intimately and seeing
your work benefit users worldwide.

<item>I see that my network adapter is supported in Linux. Can I use the
Linux driver in Etherboot? Or maybe you can adapt the Linux source. I
can send you the file if you just say the word.

<p>

No, the structure of Linux and Etherboot drivers are quite different.
There are several reasons: Linux drivers are more complicated and written
to give good performance, whereas Etherboot drivers are written to be
simple. Linux drivers are interrupt driven, whereas Etherboot drivers
are polling. Linux drivers have an elaborate support structure, whereas
Etherboot drivers are fairly self-standing. Finally Etherboot drivers
have a difficult constraint on the amount of memory available to it,
about 32kB near the top of 640kB.

<p>

But... you can use Linux drivers as a source of reverse-engineering
information. Several of the drivers in Etherboot were adapted from
Linux drivers. But don't send me the file; see previous FAQ about
volunteering. And I have the latest Linux source anyway, doesn't everyone?

</enum>

<sect1>Miscellaneous

<p>

<enum>

<item>I have a question not covered by this list.

<p>

Please join the <url name="Etherboot mailing lists"
url="http://sourceforge.net/projects/etherboot">. These are listed on the
Etherboot home page.

<p>

Other lists you can join are the Netboot mailing list (joining details
on Etherboot home page), and the LTSP mailing lists at <url name="LTSP"
url=" http://www.ltsp.org/">.  Etherboot and Netboot lists are for
general netbooting issues, while LTSP is focused more on the LTSP
packages. However there is a fair amount of overlap between the lists
and many key people are on all lists.

<p>

Posting to a list is preferable to mailing me because: you get the
benefit of a lot of experts seeing your question (no, I don't know
everything, if only because there are many configurations I have never
used); if your question is answered, a lot of people see the answer and
this helps them too; and finally you may not get an immediate (or any)
reply from me because I may be not reading my email or on holiday or
just plain grumpy :-).

<p>

Note that the Netboot mailing list is spam protected.  If your ISP has
been slack security-wise and had a machine of theirs get onto one of the
Open Relay Blacklists, then you will not be allowed to post. The only
things I can suggest are to change your ISP to a more responsible one,
or to get a Web based mailbox.

</enum>

<sect>Writing an Etherboot Driver<label id="driver">

<p>

So Etherboot does not have a driver for your network adapter and you
want to write one. You should have a good grasp of C, especially with
respect to bit operations. You should also understand hardware interfacing
concepts, such as the fact that the x86 architecture has a separate I/O
space and that peripherals are commanded with `out' instructions and
their status read with `in' instructions.  A microprocessor course such
as those taught in engineering or computer science curricula would have
given you the fundamentals. (Note to educators and students in computer
engineering: An Etherboot driver should be feasible as a term project
for a final year undergraduate student. I estimate about 40 hours of
work is required. I am willing to be a source of technical advice.)

<p>

Next you need a development machine. This can be your normal Linux
machine. You need another test machine, networked to the development
machine. This should be a machine you will not feel upset rebooting very
often. So the reset button should be in working condition. :-) It should
have a floppy drive on it but does not need a hard disk, and in fact a
hard disk will slow down rebooting. Alternatively, it should have a
another network adapter which can netboot; see discussion further down.
Needless to say, you need a unit of the adapter you are trying to write
a driver for. You should gather all the documentation you can find for
the hardware, from the manufacturer and other sources.

<p>

There are several types of network adapter architecture. The simplest
to understand is probably programmed I/O. This where the controller
reads incoming packets into memory that resides on the adapter and the
driver uses `in' instructions to extract the packet data, word by word, or
sometimes byte by byte. Similarly, packets are readied for transmission by
writing the data into the adapter's memory using `out' instructions. This
architecture is used for example on the NE2000 and 3C509. The disadvantage
of this architecture is the load on the CPU imposed by the I/O. However
this is of no import to Etherboot (who cares how loaded the CPU is
during booting), but will be to Linux. Next in the sophistication scale
are shared memory adapters such as the Western Digital or SMC series,
of which the WD8013 is a good example. Here the adapter's memory is also
accessible in the memory space of the main CPU.  Transferring data between
the driver and the adapter is done with memory copy instructions. Load
on the CPU is light. Adapters in this category are some of the best
performers for the ISA bus.  Finally there are bus mastering cards such
as the Lance series for the ISA bus and practically all good PCI adapters
(but not the NE2000 PCI). Here the data is transferred between the main
memory and the adapter controller using Direct Memory Access.

<p>

Examine the file skel.c, in the src directory, which is a template for
a driver. You may also want to examine a working driver. You will see
that an Etherboot driver requires 5 functions to be provided:

<itemize>

<item>A probe routine, that determines if the network adapter is present
on the machine. This is passed a pointer to a `nic' struct, a list of
candidate addresses to probe, and possibly a pointer to a `pci' struct.
This routine should initialise the network adapter if present.  If a
network adapter of the type the driver can handle is found, it should
save the I/O address at which it was found for use by the other
routines. In the case of ISA adapters, it may be passed a list of
addresses to try, or if no list is passed in, it may use an internal
list of candidate addresses. In the case of PCI adapters, the address
has already been found by the PCI support routines. Then it should
determine the Ethernet (MAC) address of the adapter and save it in
nic->node_addr. It should then call the reset routine to initialise the
adapter.  Finally it should fill in the function pointers for the other
routines, and return the `nic' pointer. If it fails to find an adapter,
it should return 0.

<p>

Initialising the adapter means programming the registers so that the
chip is ready to send and receive packets. This includes enabling the
appropriate hardware interface (10B2, 10BT) in the case of adapters with
more than one interface, and setting the right speed (10Mb, 100Mb) if
the hardware does not autosense and set it.  It also includes setting up
any memory buffers needed by the hardware, along with any necessary
pointers.

<p>

Note that you should program the receiver registers to allow broadcast
Ethernet packets to be received.  This is needed because other IP hosts
will do an ARP request on the diskless computer when it boots.

<item>A reset routine, that resets the adapter to a known state.
This is passed a pointer to a `nic' struct.  This can be called from
the probe routine.

<item>A disable routine, which puts the adapter into a disabled state.
This is passed a pointer to a `nic' struct.  This is needed to leave
the adapter in a suitable state for use by the operating system which
will be run after Etherboot. Some adapters, if left in an active state,
cannot be found by the operating system.

<item>A transmit routine, to send an Ethernet packet. This is passed a
pointer to a `nic' struct, the 6 byte Ethernet address of the destination,
a packet type (IP, ARP, etc), the size of the data payload in bytes, and
a pointer to the data payload. Remember the packet type and length fields
are in x86 byte order (little-endian) and the adapter's byte order may be
the reverse (big-endian). Note that the routine knows nothing about IP
(or any other type) packets, the data payload is assumed to be a filled
in packet, ready to transmit.

<item>A poll routine, to check if a packet has been received and ready
for processing. This is passed a pointer to a `nic' struct. If a packet
is available, it should copy the packet from the adapter into the data
area pointed to by nic->packet, and set nic->packetlen to the length of
the data, and return 1, otherwise 0.

<p>

A few Ethernet controller chips will receive packets from itself, as
detected by having a source address of itself. You can throw these out
immediately on reception and not bother the upper layer with them.

</itemize>

Only the probe routine needs to be public, all the other routines should
be static and private to the driver module. Similarly all global data
in the driver should be static and private.

<p>

A prototype for the probe routine should be added to the file config.c,
conditional on INCLUDE_NAMEOFNIC.  NAMEOFNIC is derived from the name
of the driver source file for your adapter by uppercasing alphabets and
converting hyphen to underscore. If the file is pop-sicle.c, then the
symbol is INCLUDE_POP_SICLE. Also conditional on INCLUDE_NAMEOFNIC should
be a struct entry containing the name of the driver and a pointer to the
probe routine. The third element of the structure should be pci_probeaddrs
in the case of PCI adapters, otherwise 0.

<p>

If the NIC is a PCI adapter, then you also need to put an entry
in the pci_nic_list array with the name, vendor and id fields
filled in. You can obtain the vendor and device ids from the file
/usr/include/linux/pci.h. It is also displayed by PCI BIOSes on bootup,
or you can use the lspci program from the pciutils package to discover
the ids.  The other fields will be filled in by the pci routines.
The symbol INCLUDE_NAMEOFNIC should be used to set INCLUDE_PCI.

<p>

Then add an entry to the file NIC so that the build process will create
Makefile rules for it in the file Roms. The build process will cause the
driver object will be pulled in from the driver library. Use the rule for
bin32/driver.fd0 or the command `cat floppyboot.bin bin32/driver.rom >
/dev/fd0' to write another instance of the driver to the floppy for
testing. Use lots of printf statements to track where execution has
reached and to display the status of various variables and registers
in the code.  You should expect to do this dance with the development
machine, floppy disk and target machine many many times.

<p>

There is another method of testing ROM images that does not involve
walking a floppy disk between the machines and is much nicer. Set up a
supported NIC with a boot ROM. Put the target NIC on the same machine
but at a non-conflicting I/O location. That is to say, your test machine
has two NICs and two connections to the LAN.  Then when you are ready to
test a boot image, use the utility <url name="mknbi-rom"
url="mknbi.html">  to create a network bootable image from the ROM
image, and set up bootpd/DHCPD and tftpd to send this over the when the
machine netboots.  Using Etherboot to boot another version of itself is
rather mind-boggling I know.

<p>

Now set up the various required services, i.e. BOOTP/DHCP, tftp, etc. on
the development machine. You should go through the setup process with a
supported adapter card on a test machine so that you know that the network
services are working and what to expect to see on the test machine.

<p>

When coding, first get the probe routine working. You will need to refer
to the programmer's guide to the adapter when you do this.  You can also
get some information by reading a Linux or FreeBSD driver. You may also
need to get the reset routine working at this time.

<p>

Next, get the transmit routine working. To check that packets are going
out on the wire, you can use tcpdump on the development machine to snoop
on the Ethernet. The first packet to be sent out by Etherboot will be
a broadcast query packet, on UDP port 67. Note that you do not need
interrupts at all.  You should ensure the packet is fully transmitted
before returning from this routine.  You may also wish to implement a
timeout to make sure the driver doesn't get stuck inside transmit if it
fails to complete. A couple of timer routines are available for
implementing the timeout, see timer.h. You use them like this (in
pseudo-code):

<code>
	for (load_timer2(TIMEOUT_VALUE);
		transmitter_busy && (status = timer2_running()); )
		;
	if (status == 0)
		transmitter_timed_out;
</code>

The timeout value should be 1193 per millisecond of wait. The maximum
value is 65535, which is about 54 milliseconds of timeout. If you just
need to delay a short time without needing to do other checks during the
timeout, you can call waiton_timer2(TIMEOUT_VALUE) which will load, then
poll the timer, and return control on timeout.

<p>

Next, get the receive routine working. If you already have the transmit
routine working correctly you should be getting a reply from the
BOOTP/DHCP server. Again, you do not need interrupts, unlike drivers
from Linux and other operating systems. This means you just have to
read the right register on the adapter to see if a packet has arrived.
Note that you should NOT loop in the receive routine until a packet
is received. Etherboot needs to do other things so if you loop in the
poll routine, it will not get a chance to do those tasks. Just return
0 if there is no packet awaiting and the main line will call the poll
routine again later.

<p>

Finally, get the disable routine working. This may simply be a matter
of turning off something in the adapter.

<p>

Things that may complicate your coding are constraints imposed by the
hardware. Some adapters require buffers to be on word or doubleword
boundaries. See rtl8139.c for an example of this. Some adapters need a
wait after certain operations.

<p>

When you get something more or less working, release early. People on the
mailing lists can help you find problems or improve the code. Besides
you don't want to get run over by a bus and then the world never gets
to see your masterpiece, do you? :-)

<p>

Your opus should be released under GPL, BSD or a similar Open Source
license, otherwise people will have problems using your code, as most
of the rest of Etherboot is GPLed.

<sect>Acknowledgements (a.k.a Hall of Fame)

<p>

The following people have contributed substantially to Etherboot. If you
feel your name has been left out, just let me know and I will fix it up.

<descrip>

<tag/Markus Gutschke/ Co-author of Etherboot. He was the person who
ported the Netboot suite from FreeBSD. He has enhanced Etherboot with many
features, one new driver and has contributed various utilities and addons.

<tag/Gero Kuhlmann/ The mknbi utilities used by Etherboot are from
Netboot.  He has also clarified the original specification by Jamie Honan.

<tag/Jamie Honan/ Jamie started Netboot off by writing the first version
that used code from a packet driver.

<tag/Martin Renters et. al/ The original authors of Netboot on FreeBSD.

<tag/Bruce Evans/ Created bcc compiler used by Etherboot/16.

<tag/Rob de Bath/ Current maintainer of bcc and associated tools like
as86.

<tag/Gerd Knorr/ Contributed MASQ for making a boot floppy without DOS.

<tag/Adam Richter/ Contributed comboot for making a boot floppy without DOS.

<tag/Claus-Justus Heine/ Contributed patch for serial console and NFS
swapping. See the contrib/nfs-swap directory for his Web page.

<tag/Dickon Reed/ Contributed display of loading status and a hack for
the 3c509 card.

<tag/David Munro/ Contributed PCI detection code originally from Linux sources.

<tag/Charlie Brady/ Donated NE2100 card so that a driver could be written,
and helped test the LancePCI driver. Spotted bug with 4.1 header code.

<tag/Rogier Wolff/ Created Intel EtherExpressPro 100 driver and binary
to hex converter.

<tag/Vlag Lungu/ Contributed patches to work with DHCP. Also contributed
a fix to match the received XID against the transmitted one, important
in a network with many requesters.

<tag/William Arbaugh/ Patches for eepro to work with 3.2.

<tag/Jean Marc Lacroix/ Contributed an improved bin2intelhex.

<tag/Jim Hague/ Contributed fixes to 3c503 driver for PIO mode, fix to
makerom for presetting EPROM bytes, and various endian fixes.

<tag/Andrew Coulthurst/ Contributed patch for making Intel eepro work
in 4.0.

<tag/Doug Ambrisko/ Contributed patches to start32.S from FreeBSD version
to make it boot Windoze after answering N to Boot from Network question.
Contributed FreeBSD support and improved serial console support which
is now merged into distribution since version 4.2.8.

<tag/Alex Harin/ Contributed patches for prepended loaders and makerom
to make bootrom PnP and PCI compatible.

<tag/Peter Dobcsanyi/ Contributed vendor and device IDs for the Netvin
NE2000/PCI clone.

<tag/adam@mudlist.eorbit.net/ Contributed RARP code as alternative to
BOOTP/DHCP. Activated by RARP_NOT_BOOTP define.

<tag/Daniel Engstrom/ Contributed a SMC9000 driver.

<tag/Didier Poirot/ Contributed an Etherpower II (EPIC 100) driver.

<tag/Martin Atkins/ Contributed mntnbi for mounting DOS NBIs.

<tag/Attila Bogar/ Contributed a bug fix to the bootmenu code and a
patch to main.c to remove looping menus on failure. Also code for ARP
replies and TFTP retransmit (#ifdef CONGESTED). Cleanup of tftp and tftpd.

<tag/Nathan R. Neulinger/ Found bug due to tu_block being declared signed
short in arpa/tftp.h on many platforms when it should be unsigned short.

<tag/David Sharp/ Contributed a FreeBSD driver for Tulip based cards. Ken
Yap ported it to Etherboot. Not tested because code needs to be written
for all the variants of the Tulip and also because no hardware available
to me.

<tag/Greg Beeley/ Contributed a 3c905b driver. Be sure to read the
release notes in 3c905b.txt before using.

<tag/Alex Nemirovsky/ Contributed patches to use BIOS call to size memory
otherwise Etherboot was trampling on top of 640kB area, which is used
by some extended BIOSes. Also contributed patches to pci.c to implement
PCI bus support on BIOSes that do not implement BIOS32, or incorrectly.

<tag/G&uuml;nter Knauf/ Suggested making the ASK_BOOT prompts more generic and
clearer. Also contributed a DOS utility for extracting the identifier string
and PCI IDs, if any, out of the boot ROM. Contributed a wake on LAN CGI script.

<tag/Klaus Espenlaub/ Contributed various cleanup patches to the code
especially in the bootmenu area, fixes for the NE2000 driver, as well as
a completely revamped start32.S.  Also introduced Rainer Bawidamann's
code, see next paragraph. Contributed further improvements in Realtek
8139 driver. Did a major rewrite from 4.4.5 to 4.5.5, see doc/maint/LOG.

<tag/Rainer Bawidamann/ Contributed a Realtek 8139 driver.

<tag/Georg Baum/ contributed a Schneider & Koch G16 driver.

<tag/jluke@deakin.edu.au/ sent in a fix for the WD/SMC8013 which I
finally verified.

<tag/Mark Burazin/ contributed a fix for Compex RL2000 NICs.

<tag/Matthias Meixner/ found a receive status bug in the RTL8139 driver.

<tag/Jim McQuillan/ provided changes to support the SMC1211 which uses
the RTL8139 chip.

<tag/Steve Smith/ Extended the 3c905b driver for other members of the
90x family. Be sure to read the release notes in 3c90x.txt before using.
Modified loader.S for some BIOSes that don't behave correctly with INT19H.

<tag/John Finlay/ Wrote a utility for programming EEPROMs on 3c90x
in situ.

<tag/Nick Lopez/ Contributed change to tulip.c to handle Macronix 98715
(Tulip clone).

<tag/Matt Hortman/ Contributed fix to eepro100 driver that fixes incorrect
latency setting. Also Makefile rule for .lzfd0.

<tag/Marty Connor/ Contributed new Tulip driver ntulip.c. Reduced RTL8139
footprint. Added support for Netgear FA310TX (Tulip clone, LC82C168 chip).
Support for 3Com905C. Romutil for 905C, which have block erase EEPROMs.
Contributed the development of liloprefix.S through thinguin.org.

<tag/Anders Larsen/ contributed mkQNXnbi, for generating tagged images
from QNX kernels.

<tag/Bernd Wiebelt/ contributed code to request vendor tags in DHCP.

<tag/Paolo Marini/ contributed the Via-Rhine driver.

<tag/Adam Fritzler/ contributed 3c529 (MCA version of 3c509) support
in driver.

<tag/Shusuke Nisiyama/ contributed a 3c595 (may work for 3c590) driver.

<tag/Igor V. Kovalenko/ contributed a Winbind W89C840 driver.

<tag/Gary Byers/ of thinguin.org wrote the LILO prefix program
liloprefix.S.

</descrip>

<sect>Copyright

<p>

The boot code from FreeBSD is under the BSD license. The code taken from
the Linux PCI subsystem and Linux NIC drivers are under GPL. Some source
files have been put under GPL by their authors.  Hence the Etherboot
distribution is in general under the GPL, but you may use parts of it
derived from FreeBSD under FreeBSD rules.  Simply speaking, the GPL
says that if you distribute a binary derived from Etherboot code you
have to provide, or promise to provide on demand, the source code.
The full conditions of the GPL are specified in the file COPYING.

<p>

Here are the copyright details, file by file:

<code>
m4_include(`sgml/Copyrights')
</code>

<p>

Send changes to this document to <url url="mailto:ken_yap@users.sourceforge.net"
name="Ken Yap">.

</article>
