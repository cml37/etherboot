<HTML>
<HEAD>
<TITLE>mknbi - make network bootable image</TITLE>
<LINK REV="made" HREF="mailto:feedback@suse.de">
</HEAD>

<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="#MKNBI_LINUX">MKNBI-LINUX</A>
	<LI><A HREF="#MKNBI_LINUX_OPTIONS">MKNBI-LINUX OPTIONS</A>
	<LI><A HREF="#MKNBI_LINUX_BOOTP_DHCP_VENDOR_TA">MKNBI-LINUX BOOTP/DHCP VENDOR TAGS</A>
	<LI><A HREF="#MKNBI_ROM">MKNBI-ROM</A>
	<LI><A HREF="#MKNBI_FDOS">MKNBI-FDOS</A>
	<LI><A HREF="#MKNBI_FDOS_OPTIONS">MKNBI-FDOS OPTIONS</A>
	<LI><A HREF="#MKNBI_DOS">MKNBI-DOS</A>
	<LI><A HREF="#MKNBI_DOS_OPTIONS">MKNBI-DOS OPTIONS</A>
	<LI><A HREF="#BUGS">BUGS</A>
	<LI><A HREF="#SEE_ALSO">SEE ALSO</A>
	<LI><A HREF="#COPYRIGHT">COPYRIGHT</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
	<LI><A HREF="#DATE">DATE</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
mknbi - make network bootable image

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
<STRONG>mknbi</STRONG> --format=<EM>format</EM> --target=<EM>target</EM> [--output=<EM>outputfile</EM>] <EM>target-specific-arguments</EM>



<P>
<STRONG>mknbi-linux</STRONG> [--output=<EM>outputfile</EM>] <EM>kernelimage</EM> [<EM>ramdisk</EM>]

<P>
<STRONG>mkelf-linux</STRONG> [--output=<EM>outputfile</EM>] <EM>kernelimage</EM> [<EM>ramdisk</EM>]

<P>
<STRONG>mknbi-rom</STRONG> [--output=<EM>outputfile</EM>] <EM>ROM-image</EM>



<P>
<STRONG>mknbi-fdos</STRONG> [--output=<EM>outputfile</EM>] <EM>kernel.sys floppyimage</EM>



<P>
<STRONG>mknbi-dos</STRONG> [--output=<EM>outputfile</EM>] <EM>floppyimage</EM>



<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
<STRONG>mknbi</STRONG> is a program that makes network bootable images for various operating
systems suitable for network loading by Etherboot or Netboot.

<P>
<STRONG>mknbi</STRONG> can be invoked with the <STRONG>--format</STRONG> and <STRONG>target</STRONG> options or links can be made to it under format and target specific names.
E.g. mkelf-linux is the same as mknbi --format=elf --target=linux.

<P>
<STRONG>--format</STRONG>=<EM>format</EM> Specify the format of the output. Currently available are nbi and elf. ELF
format only works with linux and menu. Otherwise the invocation is the same
as for mknbi. In discussions below, the mknbi form is used.

<P>
<STRONG>--target</STRONG>=<EM>target</EM> Specify the target binary. Currently available are linux, menu, rom, fdos
and dos. <STRONG>mknbi</STRONG> is not needed for booting FreeBSD.

<P>
<STRONG>--output=</STRONG><EM>outputfile</EM> Specify the output file, can be used with all variants. Stdout is the
default.

<P>
The package must be installed in the destination location before the
executables can be run, because it looks for library files.

<P>
Each of the variants will be described separately.

<P>
<HR>
<H1><A NAME="MKNBI_LINUX">MKNBI-LINUX</A></H1>
<P>
<STRONG>mknbi-linux</STRONG> makes a tagged image from a Linux kernel image, either a zImage or a
bzImage.

<P>
<HR>
<H1><A NAME="MKNBI_LINUX_OPTIONS">MKNBI-LINUX OPTIONS</A></H1>
<P>
<STRONG>--param=</STRONG><EM>string</EM> Replace the default parameter string with the specified one. This option
overrides all the following options so you should know what you are doing.

<P>
<STRONG>--append</STRONG>=<EM>string</EM> Appends the specified string to the existing parameter string. This option
operates after the other parameter options have been evaluated.

<P>
<STRONG>--rootdir</STRONG>=<EM>rootdir</EM> Define name of directory to mount via NFS from the boot server.

<P>
In the absence of this option, the default is to use the directory
<CODE>/tftpboot/</CODE><EM>%s</EM>, with the <EM>%s</EM> representing the hostname or IP-address of the booting system, depending on
whether the hostname attribute is present in the BOOTP/DHCP reply.

<P>
If <CODE>rom</CODE> is given, and if the BOOTP/DHCP server is able to handle the RFC 1497
extensions, the value of the rootpath option is used as the root directory.

<P>
If the name given to the option starts with <CODE>/dev/</CODE>, the corresponding device is used as the root device, and no NFS directory
will be mounted.

<P>
<STRONG>--ip=</STRONG><EM>string</EM> Define client and server IP addresses.
<STRONG>--ipaddrs=</STRONG><EM>string</EM> is a synonym for the same thing.

<P>
In the absence of this option no IP addresses are defined, and the kernel
will determine the IP addresses by itself, usually by using DHCP, BOOTP or
RARP. Note that the kernel's query is <EM>in addition to</EM>
the query made by the bootrom, and requires the IP: kernel level
autoconfiguration (CONFIG_IP_PNP) feature to be included in the kernel.
Note: In Linux kernels 2.2.x where x &gt;= 18, it is <STRONG>necessary</STRONG> to specify one of the enabling options in the next paragraph to cause the
IP autoconfiguration to be activated. Unlike in previous kernels in the 2.2
series, IP autoconfiguration does not happen by default.

<P>
If one of the following: <CODE>off, none, on, any, dhcp, bootp, rarp, both</CODE>, is given, then the option will be passed unmodified to the kernel and
cause that autoconfig option to be chosen.

<P>
If <CODE>rom</CODE> is given as the argument to this option, all necessary IP addresses for NFS
root mounting will be inherited from the BOOTP/DHCP answer the bootrom got
from the server.

<P>
It's also possible to define the addresses during compilation of the boot
image. Then, all addresses must be seperated by a colon, and ordered in the
following way:

<P>
<CODE>--ip=</CODE><EM>client:server:gateway:netmask:hostname[:dev[:proto]]</EM>



<P>
Using this option <STRONG>mknbi-linux</STRONG> will automatically convert system names into decimal IP addresses for the
first three entries in this string. The <STRONG>hostname</STRONG> entry will be used by the kernel to set the host name of the booted Linux
diskless client. When more than one network interface is installed in the
diskless client, it is possible to specify the name of the interface to use
for mounting the root directory via NFS by giving the optional value <CODE>dev</CODE>. This entry has to start with the string <CODE>eth</CODE> followed by a number from 0 to 9. However, if only one interface is
installed in the client, this <EM>dev</EM> entry including the preceding semicolon can be left out. The <EM>proto</EM> argument is one of the IP autoconfiguration enabling options listed above.
(Author: it's not clear to me what the IP autoconfiguration does when the
parameters are already specified. Perhaps it's to obtain parameters not
specified, e.g. NIS domain.)

<P>
<STRONG>--first16</STRONG> Use old first stage setup program (first-linux.S). By default the new first
stage setup program (first32.c) is used. The new setup program has some
advantages, including being able to detect memory &gt; 64 MB and in general
being more maintainable. --first16 is only valid for tagged images, not
ELF. It will be ignored if specified with ELF.

<P>
<STRONG>--first32pm</STRONG><EM>[=program]</EM> Use a more efficient protected mode call protocol for the first stage setup
program. This requires Etherboot ROMs version 5.0 and above and so is not
enabled by default. It can also be used to call extensions to the Etherboot
code, which paves the way for additional useful functionality without
enlarging the size of the Etherboot footprint. When a <EM>program</EM> is not specified, the default is to use the standard first stage setup
program suitable for booting a Linux kernel. --first32pm is implied by the
ELF format and does not have to be specified in this case.

<P>
<STRONG>--progreturns</STRONG> This option is used in conjunction with and only valid with the --first32pm
option to indicate to the Etherboot loader that the called program will
return to loader and hence Etherboot should not disable the network device
as is the case when the program will never return to Etherboot.

<P>
Run the program thus:

<P>
<CODE>mknbi-linux</CODE>  <EM>kernel-image</EM> [<EM>ramdisk-image</EM>] &gt; <CODE>linux.nb</CODE>



<P>
Then move <EM>linux.nb</EM> to where the network booting process expects to find it.

<P>
<HR>
<H1><A NAME="MKNBI_LINUX_BOOTP_DHCP_VENDOR_TA">MKNBI-LINUX BOOTP/DHCP VENDOR TAGS</A></H1>
<P>
<STRONG>mknbi-linux</STRONG> includes a startup code at the beginning of the Linux kernel which is able
to detect certain BOOTP vendor defined tags. These can be used to modify
the kernel loading process at runtime. To use these tags with bootpd, a
publicly available BOOTP server daemon, you can use the following syntax in
the <EM>/etc/bootptab</EM> file:

<P>
<CODE>T</CODE><EM>number</EM><CODE>=&quot;</CODE><EM>string</EM><CODE>&quot;</CODE>



<P>
For example, to specify a different root NFS device, you can use:

<P>
<CODE>T130=&quot;eth1&quot;</CODE>



<P>
The following tags are presently supported by <STRONG>mknbi-linux</STRONG>:

<P>
<STRONG>129</STRONG> The <EM>string</EM> value given with this tag is appended verbatim to the end of the kernel
command line. It can be used to specify arguments like I/O addresses or DMA
channels required for special hardware like SCSI adapters, network cards
etc. Please consult the Linux kernel documentation about the syntax
required by those options. It is the same as the <STRONG>--append</STRONG> command line option to <STRONG>mknbi-linux</STRONG>, but works at boot time instead of image build time.

<P>
<STRONG>130</STRONG> With this tag it is possible to the select the network adapter used for
mounting root via NFS on a multihomed diskless client. The syntax for the <EM>string</EM> value is the same as for the <CODE>dev</CODE> entry used with the <STRONG>--ip=</STRONG> option as described above. However note that the
<STRONG>mknbi-linux</STRONG> runtime loader does not check the syntax of the string.

<P>
The same tags will work in DHCP with the appropriate syntax for your DHCP
server configuration file.

<P>
Remember that you need to specify tag 128 in the correct format in order
for the previous tags to be valid. See the documentation file vendortags.

<P>
<HR>
<H1><A NAME="MKNBI_ROM">MKNBI-ROM</A></H1>
<P>
<STRONG>mknbi-rom</STRONG> makes a tagged image from an Etherboot <CODE>.rom</CODE> or <CODE>.lzrom</CODE>
boot ROM image. This allows it to be netbooted using an existing ROM. This
is useful for developing Etherboot drivers.

<P>
Run mknbi like this:

<P>
<CODE>mknbi-rom nic.lzrom</CODE> &gt; <CODE>nic.nb</CODE>



<P>
Move <EM>nic.nb</EM> to where the network booting process expects to find it. The boot ROM will
load this as the <EM>operating system</EM> and execute the ROM image.

<P>
<HR>
<H1><A NAME="MKNBI_FDOS">MKNBI-FDOS</A></H1>
<P>
<STRONG>mknbi-fdos</STRONG> makes a tagged image from a FreeDOS kernel file and a floppy image. Note
that the kernel image is not read from the floppy section of the tagged
image, but is a separate section in the tagged image. The bootloader has
been adjusted to jump to it directly. This means the space that would be
taken up on the <EM>floppy</EM> by the kernel image file can now be used for applications and data.

<P>
Obtain a distribution of FreeDOS with a recent kernel, probably at least
2006. It has been tested with 2012 but nothing older. You can get the
FreeDOS kernel here:

<P>
<CODE>ftp://ftp.gcfl.net/freedos/kernel/</CODE>



<P>
Follow the instructions to make a bootable floppy. Then get an image of the
floppy with:

<P>
<CODE>dd if=/dev/fd0 of=/tmp/floppyimage</CODE>



<P>
Also extract <EM>kernel.sys</EM> from the floppy. You can do this from the image using the mtools package,
by specifying a file as a <EM>drive</EM>
with a declaration like this in <EM>~/.mtoolsrc</EM>:

<P>
<CODE>drive x: file=&quot;/tmp/floppyimage&quot;</CODE>



<P>
Then run:

<P>
<CODE>mcopy x:kernel.sys .</CODE>



<P>
Then run mknbi by:

<P>
<CODE>mknbi-fdos kernel.sys /tmp/floppyimage</CODE> &gt; <CODE>freedos.nb</CODE>



<P>
where <EM>kernel.sys</EM> and <EM>/tmp/floppyimage</EM> are the files extracted above. Then move <EM>freedos.nb</EM> to where the network booting process expects to find it.

<P>
If you have got it to netboot successfully, then you can go back and add
your files to the floppy image. You can delete <EM>kernel.sys</EM> in the floppy image to save space, that is not needed. Note that you can
create a floppy image of any size you desire with the mformat program from
mtools, you are not restricted to the actual size of the boot floppy.

<P>
<HR>
<H1><A NAME="MKNBI_FDOS_OPTIONS">MKNBI-FDOS OPTIONS</A></H1>
<P>
<STRONG>--harddisk</STRONG> Make the boot ramdisk the first hard disk, i.e. C:. One reason you might
want to do this is because you want to use the real floppy. The limit on
``disk size'' in the boot image is not raised by this option so that is not
a reason to use this option.

<P>
<STRONG>--nosquash</STRONG> Do not try to chop unused sectors from the end of the floppy image. This
increases the tagged image size and hence loading time if the FAT
filesystem on the floppy is mostly empty but you may wish to use this
option if you have doubts as to whether the squashing algorithm is working
correctly.

<P>
<HR>
<H1><A NAME="MKNBI_DOS">MKNBI-DOS</A></H1>
<P>
<STRONG>mknbi-dos</STRONG> makes a tagged image from a floppy image containing a bootable DOS
filesystem. It is not necessary to build the filesystem on a physical
floppy if you have the mtools package, but you need a bootable floppy of
any size to start with. First extract the boot block from the floppy:

<P>
<CODE>dd if=/dev/fd0 of=bootblock bs=512 count=1</CODE>



<P>
Then get the DOS kernel files (this is correct for DR-DOS, the names are
different in MS-DOS):

<P>
<CODE>mcopy a:ibmbio.com a:ibmdos.com .</CODE>



<P>
Next make an entry in <EM>~/.mtoolsrc</EM> to declare a floppy to be mapped to a file:

<P>
<CODE>drive x: file=&quot;/tmp/floppyimage&quot;</CODE>



<P>
Now format a floppy of the desired size, in this case a 2.88 MB floppy, at
the same time writing the bootblock onto it:

<P>
<CODE>mformat -C -t 160 -s 18 -h 2 -B bootblock x:</CODE>



<P>
Finally, copy all your desired files onto the floppy:

<P>
<CODE>mcopy ibmbio.com ibmdos.com config.sys autoexec.bat app.exe app.dat ... x:</CODE>



<P>
If you happen to have a media of the same size you could test if the image
is bootable by copying it onto the media, and then booting it:

<P>
<CODE>dd if=/tmp/floppyimage of=/dev/fd0</CODE>



<P>
Then run mknbi-dos over the image <EM>/tmp/floppyimage</EM> to create a tagged image:

<P>
<CODE>mknbi-dos /tmp/floppyimage</CODE> &gt; <CODE>dos.nb</CODE>



<P>
Move <EM>dos.nb</EM> to where the network booting process expects to find it.

<P>
<HR>
<H1><A NAME="MKNBI_DOS_OPTIONS">MKNBI-DOS OPTIONS</A></H1>
<P>
<STRONG>--harddisk</STRONG> Make the boot ramdisk the first hard disk, i.e. C:. One reason you might
want to do this is because you want to use the real floppy. The limit on
``disk size'' in the boot image is not raised by this option so that is not
a reason to use this option.

<P>
<STRONG>--nosquash</STRONG> Do not try to chop unused sectors from the end of the floppy image. This
increases the tagged image size and hence loading time if the FAT
filesystem on the floppy is mostly empty but you may wish to use this
option if you have doubts as to whether the squashing algorithm is working
correctly.

<P>
<HR>
<H1><A NAME="BUGS">BUGS</A></H1>
<P>
Please report all bugs to the author.

<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO</A></H1>
<P>
Etherboot tutorial at <CODE>http://etherboot.sourceforge.net/</CODE> Mtools package is at <CODE>http://wauug.erols.com/pub/knaff/mtools/</CODE> Make sure you have a recent version, the ability to map a drive to a file
is not present in old versions.

<P>
<HR>
<H1><A NAME="COPYRIGHT">COPYRIGHT</A></H1>
<P>
<STRONG>mknbi</STRONG> is under the GNU Public License

<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR</A></H1>
<P>
Ken Yap (<CODE>ken_yap@users.sourceforge.net</CODE>)

<P>
<HR>
<H1><A NAME="DATE">DATE</A></H1>
<P>
Version 1.1 December 2000
</BODY>

</HTML>
